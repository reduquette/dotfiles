---
description: Use jujutsu (jj) instead of git for all version control operations
alwaysApply: true
---

# Version Control: Jujutsu (jj)

This project uses **jujutsu (jj)** instead of git. Always use `jj` commands for version control.

## Mental model

- There is **no staging area** and **no working tree** separate from commits. Every file save is immediately part of the current change (like a perpetual `git add -A && git commit --amend`).
- The **current change** (`@`) is analogous to the git staging area — it holds in-progress work.
- The **parent of the current change** (`@-`) is the "last known good" state — analogous to HEAD in git.
- Changes are identified by **change IDs** (short letter sequences like `qpvuntsm`), not SHA hashes.
- **Bookmarks** are jj's equivalent of git branches. They are named references to changes and map to remote branches when pushed.
- Conflicts are **non-blocking** — a rebase or merge that produces conflicts simply marks the change as conflicted; it does not halt the operation.
- `jj undo` reverts the last operation. `jj op log` shows the full operation history for the repo.

## Command reference

| Instead of | Use | Notes |
|---|---|---|
| `git status` | `jj status` or `jj st` | |
| `git diff` | `jj diff` | |
| `git diff --staged` | N/A | No staging area; `jj diff` shows current change |
| `git log` | `jj log` | |
| `git show` | `jj show` | |
| `git add` + `git commit` | `jj commit -m "…"` | Shorthand for `jj describe -m "…" && jj new` |
| `git commit --amend` | `jj squash` | Squashes current change into its parent |
| `git branch` | `jj bookmark list` | |
| `git checkout -b` | `jj new` + `jj bookmark set <name>` | |
| `git switch <branch>` | `jj new <change-id-or-bookmark>` | Creates child change for iteration |
| `git switch` (just move to) | `jj edit <revision>` | Directly checks out the change |
| `git push` | `jj git push` | Force-pushes by default (like `--force-with-lease`) |
| `git push -u origin branch` | `jj git push --named=<prefix>/<name>=@-` | First push: creates bookmark + pushes |
| `git fetch` | `git fetch origin` | Prefer plain `git fetch` in colocated repos — it respects `remote.fetch` config and is faster than `jj git fetch` |
| `git pull --rebase` | `git fetch origin && jj rebase --skip-emptied -s 'all:roots(immutable_heads()..@)' -d 'trunk()'` | No `jj pull` equivalent |
| `git rebase -i main` | `jj rebase --skip-emptied -s 'all:roots(immutable_heads()..@)' -d 'trunk()'` | |
| `git rebase --continue` | N/A | Conflicts are non-blocking; resolve with `jj new <conflicted> && jj resolve && jj squash` |
| `git stash` | N/A | Not needed — switch changes freely at any time |
| `git merge A B` | `jj new A B` | Creates a change with multiple parents |
| `gh pr create` | `gh pr create -wH $(jj bookmark list -r 'pr_head()' -T name) -B $(jj bookmark list -r 'pr_base()' -T name)` | Requires revset aliases (see config below) |

## Revision shorthands

- `@` — current change
- `@-` — parent of current change
- `@--` — grandparent
- `@+` — direct descendant
- `trunk()` — the main/default branch

## Core workflow

### Starting new work

```shell
jj new main              # new change based on main
# ... edit files ...
jj commit -m "description"  # finalize and start next change
```

### Iterating on a change

Work in the child change (`@`), then squash into the parent (`@-`) when ready:

```shell
# ... edit files ...
jj squash                # folds current change into parent
```

### Switching between changes

```shell
jj new <change-id>       # create child to iterate on a change
jj edit <change-id>      # directly check out a change
```

### Pushing and creating PRs

First push (creates remote branch):

```shell
jj git push --named=<user>/<branch-name>=@-
```

Subsequent pushes:

```shell
jj git push -r @-
```

Push entire stack:

```shell
jj git push -r 'immutable_heads()..(@::)'
```

### Rebasing onto latest main

```shell
git fetch origin
jj rebase --skip-emptied -s 'all:roots(immutable_heads()..@)' -d 'trunk()'
```

### After a PR is merged

```shell
git fetch origin
jj rebase --skip-emptied -s 'all:roots(immutable_heads()..visible_heads())' -d 'trunk()'
jj git push -r 'immutable_heads()..visible_heads()'
```

### Splitting a change

```shell
jj split                 # interactive; select hunks to split off
jj split -r <revision>   # split a specific change
```

### Resolving conflicts

```shell
jj new <conflicted-change>
jj resolve               # opens configured merge editor
jj squash
```

### Handling devflow integration branch merge conflicts

1. Create the fix PR from GitHub UI (from the devflow comment)
2. `jj git fetch`
3. `jj new <fix-branch>@origin <devflow-copy-of-your-branch>@origin`
4. Resolve the conflict
5. `jj describe -m "Merged <devflow-copy-of-your-branch>"`
6. `jj bookmark track <fix-branch>@origin`
7. `jj bookmark move <fix-branch>`
8. `jj git push`

### Bookmarks

```shell
jj bookmark list                          # list all bookmarks
jj bookmark set <name>                    # point bookmark at current change
jj bookmark set <name> -r @-             # point bookmark at parent
jj bookmark create -r @- <name>          # create new bookmark at parent
jj bookmark track <name>@origin          # track a remote bookmark
jj bookmark forget glob:\*               # forget all imported bookmarks
```

### Undo and history

```shell
jj undo                  # undo last operation
jj op log                # view operation history
jj op restore <op_id>    # restore repo to a previous state
```

## Exceptions

- `gh` CLI for GitHub operations (PRs, issues) is fine.
- `git fetch` is preferred over `jj git fetch` in colocated repos (respects `remote.fetch` config, faster in large repos).
- `git grep` or `rg` for code search is fine.

## Important: never use these git commands

- Do NOT use `git add`, `git commit`, `git checkout`, `git switch`, `git branch`, `git push`, `git pull`, `git rebase`, `git merge`, `git stash`. Use the jj equivalents above.
- Exception: `git fetch` is explicitly allowed and preferred.
